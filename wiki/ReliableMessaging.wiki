#summary Making ActiveMessaging connection to Stomp reliable

= Introduction =

In it's default mode, when an error occurs while the consumers are running, they raise the exception and halt the execution.  This is very different from how a running WEBrick or mongel instance would behave.

This page is all about how to make the consumers run more reliably, and be more fault tolerant rather than failing fast and hard.

= Details =

== Reliable Stomp Connections ==

The ruby stomp client, from [http://stomp.codehaus.org/Ruby+Client codehaus] already has a built in mechanism to make a connection "reliable".

By reliable it means that if the connection encounters a problem establishing or using a connection to a stomp server, it has retry logic to continue attempting to send a message rather than failing and returning nil or raising an exception.

To turn on the reliable features of the stomp connection, you can add 'connection_configuration' info to the config/messaging.rb.  There are a few properties you can set:

|| *PROPERTY*      || *DEFAULT* || *DESCRIPTION*              ||
|| :login          || ""        || login to use connecting    ||
|| :passcode       || ""        || password to use connecting ||
|| :host           || localhost || name/IP to connect to      ||
|| :port           || 61613     || port for stomp connection  ||
|| :reliable       || FALSE     || retry connection           ||
|| :reconnectDelay || 5         || time between retry         ||

These are set in 'config/messaging.rb' like the following:
{{{
ActiveMessaging::Gateway.define do |s|
  s.queue :hello_world, '/queue/HelloWorld'

  #specify connection configration as a hash
  s.connection_configuration = {:reliable => true, :reconnectDelay => 3}
end
}}}

Setting these properties will cause the stomp connection to retry on failures, and wiat 3 seconds between tries.  One bit of warning, at the moment there is no max number of retries, or maximum time to be taken trying to retry.  This means that if the connection goes bad, the stomp connection will keep trying to reconnect ad infinitem.


== Exception Handling ==

Another part of making ActiveMessaging more reliable and fault tolerent is how you handle exceptions.  Not everyone wants this to work the same way, but chances are most folks don't want the poller to shut down for every error.  So, in true rails form, there is a pretty useful default behavior, and with a little effort you can extend or change it as you like.


=== Processor on_error ===

For any Processor, when there is an error raised from calling 'on_message', this exception is passed to the processor's 'on_error' method.

The 'app/processor/application.rb' parent processor has a default implementation for the error handling in all processors that logs all exceptions extending from 'StandardError', which is the default for the 'rescue' expression.  All other Exceptions, probably of a severe and unrecoverable nature, are logged and then raised up where they will be raised up to the 'poller.rb' script.  Here is the current 'on_error' impl:

{{{
  def on_error(err)
    if (err.kind_of?(StandardError))
      logger.error "ApplicationProcessor::on_error: #{err.class.name} rescued:\n" + \
      err.message + "\n" + \
      "\t" + err.backtrace.join("\n\t")
    else
      logger.error "ApplicationProcessor::on_error: #{err.class.name} raised: " + err.message
      raise err
    end
  end
}}}

If you don't like this, just change it in 'app/processor/application.rb', or override it in each processor class that extends from this if a particular processor has a different need.

=== Poller script exception handling ===

The 'activemessaging/poller.rb' which is the main script (executed by rake) that loads and runs all the processors, and loops continuously receiving messages has its own exception handling.

It has a rescue block around the loop to quietly halt when there is an 'Interrupt', and print out any other error.  More importantly, what this block ensures is that when the poller ends, it always tries to unsubscribe from all current subscriptions in the connection, and then disconnect from stomp.

So change this at your own risk - not unsubscribing cleanly will leave activemq continuing to pass messages to client connections long since halted.

To make this script more reliable, I recommend running it using a daemon script of some type.  We use [http://cr.yp.to/daemontools.html daemon tools], or the script below.

=== Poller daemon ===

Included with the procesor generator is the creation of a 'script/poller' script.
This script uses the [http://daemons.rubyforge.org ruby daemons library] to turn the poller.rb into a daemon.  Here are the available options:
{{{
> ./script/poller -h
Usage: poller <command> <options> -- <application options>

* where <command> is one of:
  start         start an instance of the application
  stop          stop all instances of the application
  restart       stop all instances and restart them afterwards
  run           start the application and stay on top
  zap           set the application to a stopped state

* and where <options> may contain several of the following:

    -t, --ontop                      Stay on top (does not daemonize)
    -f, --force                      Force operation

Common options:
    -h, --help                       Show this message
        --version                    Show version
}}}

